<!-- markdownlint-disable -->

# Bloco A - Vault

## Aulas

### Aulas 1 - Conhecendo o Vault

Nesta aula, vamos explorar o gerenciamento de segredos, focando em como proteger informações sensíveis em nossas aplicações. Usaremos a aplicação Upload Width Server como exemplo, que já possui algumas chaves de acesso. Discutiremos a importância de não deixar essas informações expostas no código, utilizando arquivos .env e, em seguida, abordaremos ferramentas como o Vault da HashCorp e o Secret Manager da AWS. O objetivo é garantir que nossas aplicações acessem segredos de forma segura e eficiente.

### Aula 2 - Criando as Nossas Primeiras Secrets

Nesta aula, exploramos a instalação e configuração do Vault, uma ferramenta de gerenciamento de segredos. Discuti as opções de instalação, tanto localmente quanto via Docker, e como iniciar o servidor em modo Dev. Abordei a interface do usuário do Vault, onde podemos criar e gerenciar segredos, além de destacar a importância do versionamento e boas práticas de segurança.

### Aula 3 - Configurando a Aplicação

Nesta aula, exploramos a integração da nossa aplicação com o Vault usando a biblioteca NodeVault. Começamos instalando a lib e configurando a leitura de secrets, focando em operações de leitura por enquanto. Discutimos boas práticas, como desacoplar a aplicação do Vault, permitindo que ela apenas receba os valores necessários. Também abordamos a estrutura das variáveis de ambiente e como injetá-las na aplicação.

### Aula 4 - Entendendo Melhor o env

Nesta aula, refatoramos um código para centralizar configurações em um arquivo chamado secret.de. Discutimos a importância de não deixar informações sensíveis no código e como usar variáveis de ambiente de forma eficiente. Abordamos a prática de injeção de variáveis em tempo de inicialização da aplicação, evitando chamadas desnecessárias ao Vault. Também falamos sobre políticas de acesso e como configurar permissões no Vault, além de mencionar a integração futura com Kubernetes e o Secret Manager da AWS.

## Transcrição

### Aulas 1 - Conhecendo o Vault

Fantástico! Então vamos dar agora início ao nosso conteúdo aqui de Secret Management, ok? Que é justamente ali o ponto para a gente conseguir entender e evoluir no aspecto ali de como que a gente trata as informações sensíveis da maneira correta. Então, até então aqui, na verdade a gente nem entrou muito no detalhe, eu estou aqui com a nossa aplicação aberta, o nosso Upload Width Server, que inclusive tem aqui aquelas configurações que nós fizemos até o último módulo, olhando ali para o campo da observabilidade, que nós fizemos ali inclusive alguns testes com o próprio New Relic, então é a mesma aplicação, ela está idêntica aqui, não tem nada demais. Só que esta aplicação, ela tem algumas informações aqui que poderiam ser informações sensíveis. Então nós temos aqui, por exemplo, o Access Key ID, o Secret Access Key e assim de forma sucessiva. Temos aqui também algumas informações do próprio New Relic que nós fizemos ali a nível de teste e também nós simulamos aqui, entre aspas, um banco de dados que também teria ali informação sensível. O grande ponto aqui é o seguinte, como é que nós vamos, de fato, armazenar essas informações da maneira mais segura possível? Porque quando nós falamos aqui de um arquivo .env, desta forma aqui, querendo ou não, a gente resolve um problema, que é justamente não deixar essa informação no meio do código. Então, por exemplo, se a gente tem aqui o CloudFare Access ID, a gente pesquisa ele aqui, ele está sendo passado aqui no meio do código, no env.ts, mas ele está sendo referenciado aqui através do arquivo env, e ele é usado aqui em determinados pontos do nosso código. Então, quando a gente trabalha com .env aqui no caso, a gente já consegue resolver esse problema. Porque caso nós não fizéssemos desta forma, a gente teria que passar aqui hardcoded, por exemplo. A gente passaria aqui hardcoded. E o grande ponto aqui é que, primeiro, a gente vai mandar esse código para o nosso GitHub, para o nosso funcionamento. Então, você estaria comitando ali a sua key. Segundo, que nós não conseguiríamos trabalhar multiambiente. Então, por exemplo, se eu estou falando de staging, eu teria um XSK de staging. Se eu estou falando de produção, eu teria outro XSK. Então, como eu não tenho variável de ambiente, como o próprio nome sugere, eu não teria esse controle também. E, obviamente, a parte de reaproveitamento. Caso eu for utilizar isso em muitos pontos do código, eu teria que sair replicando isso N vezes ali para conseguir contemplar. Então, quando a gente trabalha com um arquivo aqui, a gente resolve esses problemas todos. Mas a questão com relação à segurança, isso não é resolvido. Então, a gente não vai conseguir resolver esse problema. Porque ainda, sim, eu tenho aqui a informação no .env, que é uma informação aberta. Então, até no módulo que nós vimos de deploy, a gente tem que passar essa informação dentro de uma espécie de config map, um mapeamento de configuração, e dentro do servidor essa informação fica exposta. E aí, qual é o grande ponto desse módulo aqui? É justamente a gente configurar e deixar essa informação de uma maneira um pouco mais segura, ok? E nós vamos ver isso de duas formas, de duas maneiras. Eu E nós vamos ver isso de duas formas, de duas maneiras. Eu sempre gosto de trazer aqui duas formas de fazer o fluxo em si. Então, primeiro ponto aqui, nós vamos ver uma ferramenta chamada Vault, que a gente vai entender como ela funciona agora. E em um segundo momento, nós vamos passar pelo Secret Manager, que é uma ferramenta gerenciada pela AWS. E aí, qual que é a ideia aqui? E na verdade, Anderson, só um parênteses, né? Cada Cloud Provider também vai ter o seu Vault, ok? Então, se a gente for lá na Google, tem o Vault dela. Se a gente for lá na Azure, ele vai ter o Azure Key Vault e assim de forma sucessiva, beleza? Então, só para trazer esse ponto, é comum que cada provedor de cloud ali tenha o seu próprio serviço para trabalhar com o Secret, ok? E nós temos também o Vault, que é uma ferramenta super conhecida, é uma ferramenta da HashCorp, então, por exemplo, ferramentas que a HashCorp possui ali, a gente está falando do Terraform, estamos falando do Waypoint, estamos falando do Packer, do Vagrant, do Nomad também, que é ali um concorrente do Kubernetes. Ele também orquestra cargas de trabalho em um container. Tem também o Consul, tem o Bounder. Então, tem várias ferramentas. A HashCorp tem uma atuação bem relevante no mundo DevOps. E ela também tem o Vault, que é justamente essa ideia. A gente conseguir gerenciar os nossos secrets, os nossos segredos, e proteger também os nossos dados sensíveis. O Vault funciona aqui de duas maneiras. A gente vai ver aqui a maneira Open Source, porque, como eu disse, a gente vai explorar ali depois um pouquinho o Secret Manager e aí, obviamente, Closed Source, beleza? Aqui a gente vai trabalhar com o Open Source, mas também você pode pagar. Então, ele tem também a opção aqui do nosso Cloud, né? E você pode usar também o... Me falhou aqui, porque são vários serviços, né? Mas o Vault, de maneira paga aqui, dentro da própria plataforma, né? Que é o HCP, né? Que é o HashCorp Cloud Platform. Então, dá para você utilizar ali. Salvo engano também, tem ali uma cota gratuita. Então, é uma opção, né? Para fazer algumas configurações de maneira gratuita então é uma opção para fazer algumas configurações de maneira gratuita mas tem que ver sempre a cota Ok nós aqui não vamos trabalhar com a Cláudia da rascop nós vamos trabalhar aqui de maneira a gente mesmo digamos assim a gente vai subir aqui o volte e ver como ele funciona na nossa máquina Beleza então em resumo é isso ok o volte ele serve para gente conseguir gerenciar a simples E aí no final do dia ao invés da aplicação buscar isso de um .env, ela vai buscar isso do Vault. Então, você, na verdade, vai fazer uma conexão com o Vault no start da sua aplicação para resgatar essas informações e colocá-las ali no código. Então, basicamente, é essa a ideia, é esse o problema que ele visa resolver. E aí aí nós podemos trabalhar, por exemplo, com rotação de key, com tempo de expiração. Então, por exemplo, eu tenho aqui uma conexão com o meu banco de dados. Eu posso configurar uma rotação. Então, por exemplo, a cada deploy eu posso rotacionar a senha do meu banco, o usuário do meu banco. Então, mesmo que a gente tenha algum tipo de vazamento, alguma coisa do tipo, a gente tem essa rotação também de maneira automatizada e a aplicação consegue recuperar isso a cada bootstrap, a cada subida. Então você consegue também ter um controle muito maior com relação às suas informações secretas. E aí um ponto também que vale ressaltar é que quando a gente vai trabalhar com um vault da vida, por exemplo, é mais comum que tudo nosso fique no vault. Então é comum que você, na verdade, deixe todas as suas configurações no vault e não esse meio termo. Uma coisa fica aqui, outra coisa fica no vault. Então isso não vai fazer muito sentido para a gente. Nós vamos basicamente configurar tudo, mesmo que não seja secret. E aí a gente tem um ponto único para acessar variável de ambiente seja ela de configuração que não seria de fato uma Secret seja ela uma variável de configuração com dado sensível Ok então a gente vai basicamente deixar os dois tipos dentro do volte para ficar ali uma maneira um pouco mais simples para você não precisar configurar por exemplo. Envi e também o. Você configura somente um e aí é isso mesmo. Fica ali dessa forma esse controle. Beleza? Então, em resumo é isso. E só para essa aula não ficar muito longa, vamos fazer aqui um breve corte e na aula seguinte a gente vai fazer aqui a configuração do vault e começar a brincar e começar a integrar com a nossa aplicação.

### Aula 2 - Criando as Nossas Primeiras Secrets

não disponível

### Aula 3 - Configurando a Aplicação

Pronto demais. Então, dando sequência, já temos aqui algumas secrets de acordo com o que nós criamos, já foram definidas, já criamos aqui também dentro da nossa engine, do nosso search engine, então temos aqui os valores de acordo com a nossa aplicação, inclusive ela leia esses dados de fato do nosso volte Ok E aí a primeira coisa que nós vamos fazer aqui é justamente instalar uma lib do volte dentro da nossa aplicação para que seja possível ali a nossa aplicação se conectar com o volte e para isso a gente vai usar aqui a lib que é o NodeVault. Esta lib aqui, NodeVault. E basicamente nós vamos fazer a instalação dela e é bem simples aqui a integração. Não tem muito segredo, é bem tranquilo mesmo. Inclusive nós poderíamos fazer aqui operações de escrita. Nós aqui faremos apenas operações de leitura. Então escrita via aplicação nunca vai ter, pelo menos por enquanto escrita via aplicação nunca vai ter, pelo menos por enquanto, não. Obviamente, a gente vai ter depois mecanismos de escrita, porém, no campo da infraestrutura, a aplicação em si, ela só vai ler ou ela vai receber esses valores, ok? Então, para começar aqui o exemplo, a gente vai basicamente instalar aqui a lib node vault, que é a lib oficial, ok? Então é a própria lib da HashCop, a gente até pode dar uma olhada aqui. Então é a lib de fato oficial para fazer essa integração. Nós temos também algumas outras libs, ok? Que vão fazer isso para a gente, mas esta lib aqui é a lib recomendada, inclusive ela é bem atualizada, tá? Então ela foi atualizada há 8 dias atrás, ela tem bastante download ali também, é uma lib bem ativa nesse sentido, beleza? Então, é isso. Vamos aqui voltar no nosso terminal e vamos aqui no nosso widget server fazer a instalação desse pacote. Então, pnpm install, node-volt, né? Node-volt. Vamos aqui fazer a instalação e vai instalar aqui rapidamente para gente beleza então já foi instalado a nossa dependência podemos inclusive colocar aplicação para rodar deixando aqui um pnpm randeve para ver se tá funcionando tá tudo certo tá tudo ok beleza então vamos voltar aqui no código. Fechar essas abas aqui. Deixa eu minimizar aqui também. E vamos aqui no nosso server. No start da aplicação a gente vai colocar aqui. Até poderia ficar aí um arquivo separado. A gente depois pode estruturar pra ficar assim. Mas por hora vamos colocar aqui no server mesmo, na raiz. Pra gente já ver se vai conectar. E aqui vai ser bem tranquilo. Então a gente basicamente vai fazer aqui a escrita então vamos lá importe chamar aqui de volta vamos fazer a o importe dele aqui do novo de volta no de volta desta forma aqui a gente pode criar aqui também uma conste a óios certo a gente pode inclusive te parla aqui que vai ser o volte. Volte óbvio dessa forma aqui eu vou até mudar essa colocar e para ficar um padrãozinho aqui colocar dessa forma ele então volte. Volte óbvios e aqui nós vamos ter algumas opções. Então, se nós voltarmos aqui na sugestão, o que ele faz aqui? Ele pede para a gente passar o API version, o endpoint e o token. Beleza? Então, é basicamente isso que nós vamos passar. Então, aqui vamos ter o API version. E no caso aqui, o nosso API version é o v1. Ok? O v1 do vault, por enquanto. Então, v1. Ele vai pedir também pelo endpoint que o nosso caso aqui vai ser o http dois pontos barra barra 127.0.0.1 barra ou melhor dois pontos 8200 que nada mais aqui do que o mesmo a gente põe de que nós estamos aqui acessando a interface e ele vai pedir também o tolho então vamos passar aqui também o toque por enquanto vamos passar aqui também o token. Por enquanto, vamos passar aqui como root. Depois a gente faz uma mudança também. E aí, claro, óbvio, né? E como que a gente faz com o token do vault? Aqui, como ainda é um cenário bem inicial, a gente, por enquanto, está deixando na aplicação, ok? Mas, como nós vamos ver também, inclusive, o Kubernetes ali no próximo módulo, a gente vai deixar isso para o próximo módulo, mas a gente pode trabalhar desacoplando isso da aplicação. Então, como boa prática, a aplicação não precisa conhecer o Vault, ela precisa somente dos valores. Então, a gente pode pegar basicamente o Vault, colocar as informações dentro dele de acordo com a aplicação, mas ter um componente na infraestrutura que vai pegar essas informações e injetar na aplicação. E aí a aplicação, ela nem precisa saber se você está usando o Vault ou qualquer outra ferramenta, inclusive, poderia ser outra ferramenta, e vai muito na linha do que nós vimos ali em observabilidade, com OpenTelemetry, por exemplo, e tudo mais. Então, a ideia é que a aplicação nem fique sabendo. Aqui, para esse critério inicial, vai ser desta forma para gente obviamente conhecer a ferramenta e testar mas a gente depois vai evoluir também esse cenário Ok então é isso basicamente tá E aqui a gente pode seguir na nossa configuração que é relativamente muito na verdade antes aqui né só um ponto pode colocar também já instanciação aqui então const vault vai receber a instância aqui do vault com as options, ok? Então fica tudo certinho ali pra gente, tá? Isso aqui poderia ficar em um arquivo, como eu falei, não tem problema, aqui eu tô colocando no próprio server.ts Então aqui é isso, a gente faz a importação do nosso node vault, colocamos aqui as options, que inclusive elas poderiam ficar diretas aqui no client também, então não tem opção. Mas se você quiser passar aqui, também não tem problema, e a gente só passa o objeto aqui na instance. Beleza? Show. E agora a gente aqui no start da nossa aplicação, a gente pode verificar o seguinte. await, await, vault.read. O read aqui é justamente para a gente ler o valor lá do vault. Então aqui ele vai quebrar o nosso await, porque a gente tem que falar aqui de um contexto assíncrono, então passar aqui o async. E a gente pode também passar aqui um const values só para a gente ver os valores que ele vai conseguir resgatar para a gente. Eu inclusive já vou colocar aqui um log.info values desta forma aqui. conseguir resgatar pra gente. Eu, inclusive, já vou colocar aqui um log.info values desta forma aqui, ok? E aí, pra gente ver os tais valores, é bem tranquilo, tá? Então, aqui vai ser um read e o read, ele nada mais aqui pede do que o path, ok? E o path aqui vai ser um barra secret barra data, ok? Barra o nome que nós definimos aqui que foi widget server Station Ok então vou copiar aqui barra desta forma ah mas e se eu tiver por exemplo feito a criação de um KV por exemplo como que seria seria mais ou menos a mesma ideia Ok vai ser ali no caso KV bar data barra o nome que você definir aqui da sua secret barra secrets. A gente até pode fazer um exemplo, mas é mais ou menos a mesma estratégia ali. Se você também for aqui navegando pelas pastas, digamos assim, pelos diretórios, você vai ver uma estrutura bem similar. O que difere é que você tem que passar o data aqui antes. Então, secret barra data barra o nome ali do que você definiu como path. Beleza? Então, secret barra data barra o nome ali do que você definiu como path. Beleza? Então, é isso. Vamos ver se ele já está funcional aqui. Opa, deixou. Vou dar aqui um pnpm novamente para ver se ele está pegando. Ele não pegou nada. Vamos, inclusive, fazer um debug aqui para ver. Barra secret barra data. Barra secret barra data. Barra widget server staging aqui pelo nosso contexto está correto a gente pode até fazer um teste para averiguar mas provavelmente ele vai dar 404 então até ele encontrar alguma coisa ele só não está logando para a gente, deixa eu colocar um por desencargo um console está logando para a gente. Deixa eu colocar um por desencargo aqui, um console.log só para a gente ver. Ah, beleza. Então, na verdade, foi o nosso log ali que está zoado, mas aqui, o que importa para a gente é isso tudo aqui. Então, a gente tem aqui o data.data e aqui dentro nós temos as nossas variáveis. Então, se nós passarmos aqui o values.data, só para a gente ver, tem aqui, né? E aí, data.data, a gente vai conseguir ter acesso aos nossos valores. Então, aqui, na verdade, já está resolvido, tá? A gente basicamente poderia pegar esses valores aqui e inferi-los ali nas nossas variáveis de ambiente, ok? Então, nós já conseguimos resgatar. Obviamente, o valor vai ficar criptografado do lado do volte mas quando a gente faz aqui a leitura desse valor ele já vem aberto para gente Ok o grande ponto é que a aplicação ela não tem essa informação digamos que dentro de um envio pelo menos aqui nesse contexto não o que a gente tá resgatando de maneira dinâmica eu tô basicamente aqui fazendo por debaixo dos panos aqui é uma chamada de API, com o token ali do Vault, e essa chamada de API traz para a gente ali os valores. Então, basicamente é isso. E aqui seria basicamente fazer a injeção desse contexto dentro aqui do nosso env.ts. Então, ao invés de pegar aqui do process.env, a gente poderia pegar direto aqui do values que nós estamos trazendo do nosso vault. Como nós vimos ali, a ideia é que a gente tenha esse controle, ou seja, todas as variáveis elas deveriam ficar no vault de maneira dinâmica, então aqui não seria nenhum problema. Inclusive a gente pode até aproveitar esse resto de aula e definir também essas variáveis e aí na próxima aula a gente só configura aqui essa parte do env e é isso, né? Então só pra gente ver rapidinho aqui nós já colocamos as variáveis, né? São cinco variáveis do Cloudflare, certo? São cinco variáveis e aqui nós temos mais quatro, nós já colocamos ali a de senha então a gente vai definir aqui basicamente o nosso user, tá? Então vou Criar uma nova versão. O nosso user que é root. Vamos colocar também a nossa porta. A gente não vai colocar. Beleza. O nosso db. Que vai ser o widget server. Desta forma aqui. Beleza também. O nosso New Relic AppName. Aqui é até bom que a gente tem várias variáveis, então fica até um pouco mais fácil para exemplificar. E também o nosso New Relic License Key. Desta forma, aqui com a nossa aqui. Lembrando também que no caso ali do banco, caso você não queira manter a porta desta forma aqui, você pode na verdade criar uma variável só. Aqui nós fizemos desta forma, mas você poderia criar, por exemplo, somente uma variável ali com a connection string no caso, né? E aí você já tem a porta nesse endereço completo. Ao invés de você segmentar por usuário, senha, DB, você poderia simplesmente ter ele por cima isso é real alguma coisa assim e aí essa URL ela teria tanto usuário quanto a senha também a porta e o nome do banco mais o endereço ali para chegar até o rosto tá então tem essa estrutura também poderia ser uma forma um pouco mais fácil de lidar com a gente você teve n variáveis ali para controlar o banco Beleza então também uma dica interessante mas por, ficará desta forma. Então, a gente mudou aqui, já tem um tanto de variável. Se nós restartarmos aqui a aplicação, ela tem que trazer essas novas variáveis para a gente. Então, já está também tudo certinho aqui. Então, é isso. Fizemos aqui essa primeira parte, essa primeira configuração. E na próxima aula a gente volta só para organizar aqui essa estrutura do .im e como que ele está pegando essas informações.

### Aula 4 - Entendendo Melhor o env

o processo agora a gente basicamente vai primeiro fazer uma dar uma refatorada aqui perdão e também entender ele com relação ao mts a gente vai ali fazer alguma operação como que isso vai ficar e alguns porém também são importantes a gente trazer aqui beleza então primeiro passo aqui é o seguinte a gente vai criar um arquivo aqui dentro de infra só para centralizar essa configuração que eu vejo ficar aqui no server.de a gente vai basicamente criar aqui um arquivo esse arquivo ele vai se chamar secret.de Ok arquivo bem simples ele não tem nenhum tipo de grande complexidade então a gente vai ter aqui nada mais o que eu importe volte aqui certo do nosso do nosso no de volta oi lodi eita hoje tá meu pai aqui tá muito bom vamos aqui inclusive copiar para ganhar um tempinho então a gente pode copiar aqui a mesma coisa que nós já fizemos ali então a gente joga aqui dentro e a gente vai exportar então deixa eu remover daqui remover daqui e a gente pode exportar somente esse carinha aqui como depois então export default dessa forma aqui acho que já tá ok tá a gente pode também só para manter a boa prática manter esse toque por fora então eu vou criar aqui mais uma variável tá vamos criar aqui é secret token Lembrando que aqui a gente vai discutir sobre isso na sequência, que é só para a gente não deixar a informação no meio do código. Então, vou criar aqui essas três informações para ficar mais fácil. Então, Secret API Version, que nós vamos ter aqui. o que nós vamos ter aqui e dessa forma Secret API o endpoint dessa forma aqui e Secret API o ou quem dessa forma aqui e aí a gente pelo menos não deixa ali no meio do nosso lindo código, ok? Claro que aqui tem as ressalvas de segurança que nós já vimos ali, mas a gente consegue por hora manter desta forma, beleza? Então aqui a gente vai, a gente pode apagar isso daqui, não tem por que ficar aqui. Isso aqui a gente pode deixar por enquanto, tá? E aí aqui no nosso secret a gente pode acessar direto a variável. Então process.env. O que a gente quer aqui. Que é o secret version. A gente pode até passar ele ali no nosso env. Mas não vou fazer isso por enquanto. Então a gente acessa direto aqui mesmo. Process.env. Secret API endpoint. E o nosso token também. Então process.env ó o nosso tô aqui beleza então aqui dentro vai dar problema é isso a frente continuar simulando pode podemos importar aqui pode se curtir from a ponto barra infra barra e aqui a gente pode simplesmente substituir por sql, ok? acho que ele vai ter aqui .read .read, é isso então vamos fazer aqui de novo para ver se está funcionando está funcionando, então um pequeno refact aqui e está tudo ok o grande ponto aqui é o seguinte, para a gente conseguir substituir o envts isso vai ficar inclusive como um desafio ali, por quê? quando a gente trabalha com o volte é um ponto que nós não vamos conseguir entrar agora a gente também fala do componente ali do volte aí gente beleza aqui que nós poderíamos fazer poderia ser uma opção a gente poderia simplesmente pegar este arquivo aqui nosso centralizar esse arquivo como o responsável por em de fato porque hoje ele só tem aqui aquelas variáveis iniciais, a gente acabou não evoluindo este arquivo aqui, criar aqui uma classe ou uma função assíncrona, no contexto assíncrono, para a gente conseguir fazer o read e, de acordo com a invocação deste arquivo aqui, todo mundo teria acesso ali a CIF, ok? Isto é uma opção. Qual que é o problema? A gente ter acesso ali assim ok isso é uma opção Qual que é o problema a gente até poderia fazer aqui mas qual que é o grande problema problema é que a gente vai toda hora bater no volte então toda vez que alguém por exemplo fizer uma chamada em alguma roda que usa variável de ambiente isso não tá em memória ele vai ter de maneira assim que eu não ter que bater no volte Ok e isso obviamente não é nenhuma boa prática primeiro porque você vai ter latência. E segundo porque você vai também sobrecarregar o vault. Então geralmente a boa prática é a seguinte. A gente tem aqui um componente que é um agent. Ele é um agente de fato. E ele injeta as Envy Vars em tempo de subida. Então na prática aqui a gente vai usar sempre o Process Envy. É mais ou menos como se fosse aqui no dockerfile, não sei se aqui a gente vai ter o exemplo, mas quando a gente usa aqui, por exemplo, o env, ok? Que nós queremos ali passar uma informação pra dentro do container. Então é mais ou menos essa a ideia, ok? No final do dia ele faz a injeção, mas ele vai fazer isso somente no start da aplicação. Então, após isso, a informação fica em memória. E aí eu não preciso ficar toda hora batendo no vault lá pra pegar a informação, ok? Então, por hora, é isso. Se a gente quiser ali, a gente pode fazer. Fica aí o desafio. É relativamente simples. Seria aqui criar um contexto de função pra gente ter o contexto assíncrono aqui dentro do Node e fazer basicamente o que a gente está fazendo aqui, só que dentro aqui do envts. O único ponto de observação é esse, não é comum utilizar dessa forma, mas daria ali para fazer uma simulação. A nível de próximo passo, a gente vai trabalhar com o conceito de sidecar, lá no módulo do Kubernetes. E aí vai ser perfeito, porque nós já temos aqui o conceito do nosso querido vault, e ali com sidecar ele justamente pode ser um container, seria ali um start container que a função dele é ir lá no vault pegar, de acordo com o nosso path aqui, ele pega esses valores e ele injeta na aplicação como variável de ambiente, então pra aplicação continua sendo ali um process.env .alguma coisa, a aplicação nem teria, por exemplo, esse arquivo aqui, ela nem vai conhecer token, ela nem vai conhecer o vault, Ela não conhece nada disso. Ela conhece nada mais do que a Envy. Beleza? Mas por enquanto a gente está aqui num fluxo mais de conhecer o vault. Por isso que a gente fez dessa forma aqui. Está super dentro. E é legal a gente já ter esse contexto justamente para a gente conseguir também enfim, no futuro ali de fato já conseguir entrar nesses assuntos de maneira mais contextualizada. Então, basicamente é isso que a gente tinha para ver aqui de volta. Tem mais alguns pequenos pontos que a gente vai também ver ali com uma frequência maior em Kubernetes, mas que vale aqui mencionar é com relação à política de acesso, que é bem interessante. Então, aqui nós temos uma política só, que é via token, que é o default, mas você pode criar vários. Se você quiser, por exemplo, falar que você vai usar aqui uma autenticação via token JWT, via Open Edge Connect, via, por exemplo, username, você poderia criar aqui, por exemplo, os seus usuários, via, por exemplo, GitHub, Okta, conectando ali com algum single segment que você faz ali a utilização, você consegue. Ele também tem MFA, você pode também configurar o MFA dentro dele. Tem também a questão aqui do OpenID Connect Provider, você pode criar aqui o seu aplicativo e integrar ali da maneira que você bem precisar, além de grupos e também entidades. Então é bem interessante aqui, bem completinho nesta parte. E ele também tem aqui a política, que é o Access Control List aqui, as políticas de acesso, que basicamente nós já temos aqui o default. Então ele tem aqui algumas políticas bem interessantes. O legal é o seguinte, a sua aplicação em si, nesse contexto aqui, ela está chamando o vault. Como nós falamos aqui, a gente no futuro vai ter ali a remoção dessa lógica da aplicação não vamos mais fazer isso beleza só que fazendo ou não é legal você definir algumas políticas então por exemplo da forma que nós estamos trabalhando aqui dentro do nosso circuito engine né dessa forma aqui você poderia fazer o quê? Você poderia aqui escrever dentro desse bucket aqui. Podemos chamar isso aqui de um bucket. E você pode criar políticas, que podem ser políticas default ou não. Se você quiser, você pode criar outra política também. Show. Que bloqueia isso. Então você pode falar, por exemplo, o quê? O token aqui, por exemplo. Vamos até fazer um dia exemplo aqui que fica interessante. A gente pode falar o seguinte. Que o nosso... Vamos editar política tá então a gente passa aqui o nosso pé é tudo baseado em pé dentro do Volta Ok então nosso pé secret barra deita só verificar aqui o caminho que é o barra o WidgetServerStaging, por exemplo. Ele, a gente vai definir aqui as capabilities dele. Então, a gente pode falar que a única capacidade dele aqui, então, capabilities, vai ser a de leitura. E aí você não tem mais acesso de escrita. E aí você pode criar, inclusive, ACLs de acordo com tokens. Então, você pode ter, por exemplo, tokens que são somente leitura. Tokens que são leitura e escrlkien né então você pode ter por exemplo tolkien são somente leitura tolkien que são leitura e escrita né rede right ali por exemplo então aqui você tem um controle muito bom também com relação a isso então se você por exemplo quiser é configurar melhor o seu painel é uma opção legal é o para fazer alguma caquinha aqui, deixa eu ver. Secret barra data. Qual foi o erro? Ele falou que... Capabil... Opa! Capabilities. Perfeito. Então aqui seria um exemplo. Então a gente pode criar inclusive políticas específicas aqui. Você pode criar de acordo também com os seus buckets, com os seus engines. Você tem a default, você tem também uma política root aqui que não pode ser alterada. E aqui você pode ver também como ele funciona. Então isso aqui é bem interessante. E você obviamente tem ali um aspecto de proteção no seu contexto. Então você consegue aqui ter um controle realmente de quem vai acessar, de quem ali vai fazer deleção ou não. Enfim, de quem vai somente ler, por exemplo. Então são opções bem legais aqui que o Vault fornece e nós também não exploramos muito as outras engines Ok porque a gente está mais focado aqui no campo da aplicação e no campo da aplicação realmente o que vai importar para gente é o cabelo beleza mas a gente pode ali pensar até no kubernetes em algumas opções que podem fazer sentido aqui para gente quando a gente vai falar de governar essa gente vai falar um pouquinho sobre Secret e ConfigMap, tá? Então aqui o objetivo é explorar mais ferramentas por fora, né? Então volte a um exemplo, a gente também vai explorar um pouquinho ali do Secret Manager na próxima aula, mas o Kubernetes também, ele traz ali muito entre aspas uma ideia entre ConfigMap e Secret, então dá também pra brincar um pouquinho com ele nesse sentido. Mas enfim né no campo da aplicação realmente o nosso objetivo maior é que velho mas caso você também que ele explorar ali outros contextos né como ela e dá por exemplo top-t e tudo mais também são opções aqui que existem e são possíveis também de você usar então você acaba também conseguindo trazer o volte para um contexto até mais amplo né você pode ali falar de outros aspectos dentro dele então é bem interessante show então basicamente é isso nas próximas aulas nós vamos falar um pouquinho sobre o secret Manager perdão secret Manager lá na WS né que é um serviço de gerenciado serviço pago beleza e no próximo módulo como eu bem venho aqui trazendo spoilers nós vamos falar sobre o Kubernetes e também nós vamos adentrar ainda mais nesse aspecto aqui do Vault, mas obviamente são conhecimentos que não têm uma relação direta, então por isso que a gente está aqui justamente trazendo aulas mais voltadas para essas ferramentas e depois a gente vai focar melhor nessas integrações, ok? Então é isso, eu espero você para a próxima aula. Um grande abraço.

